	Документация на домашно №3

Използваме main функцията за реализация на интерфейса на програмата. Реализираме следните методи :

void changeParameterValue(char* fileName, char* parameter, char* newVal, int flag)

Тя приема име на файл, име на параметъра, на който искаме да променяме стойността, самата нова стойност и flag, който приема стойност 0 или 1 в зависимост от това дали е подаден като аргумент -s или -S.
Правим валидация за името на параметъра, също така дали подаденият файл съществува и дали стойността е валидна, както и флагът. За тази цел сме създали допълнителен файл, който пази всички възможни видове параметри. Използваме три променливи - type, position и num, които ни казват съотвено от какъв тип сегмент е подаденият параметър, кой поред от 3те възможни параметъра за даден сегмент е този подаден параметър и понеже текстовите сегменти могат да са повече от един, num ни казва кой точно търсим. После с командата read минаваме по всеки един сегмент, запазвайки байтовете в буфер и проверяваме всеки път какъв тип сегмент имаме като променливите textNum, numericNum и byteNum пазят съответно на кой сегмент сме в момента. Type 0 отговаря на текстов, type 1 на numeric и type 2 на byte. След като установим правилният сегмент, на който ще променя стойността на някой от параметрите, проверяваме дали трябва да променяме бита за параметъра. Ако се налага го правим с побитови операции. За конкретната реализация получаваме информация от тук : https://stackoverflow.com/questions/47981/how-do-you-set-clear-and-toggle-a-single-bit. След това с команда open отваряме отново същия файл, този път за писане, поставяме с lseek указателя на правилното място, взимайки предвид колко сегмента сме прочели до момента и позицията на която се намира параметъра и записваме новата стойност с write. Разглеждаме три възможни случая за трите вида сегменти като ако търсеният е numeric превръщаме подадената стойност в integer и записваме с write директно integer. Ако сегментът е byte правим същото нещо, ако параметърът е цифра, иначе записваме символчето като char. Накрая ако не е влязъл в нито един от случаите казваме на потребителя със съобщение, че в подадения файл няма сегмент, съдържащ подадения параметър и затваряме дескрипторите.

void showValue(char* fileName, char* parameter, int flag)

Тази функция приема файл, параметър и флаг, който казва дали подадената опция е -g или -G. Отново използваме функция initialiseData, за да разберем подаденият параметър за кой точно сегмент отговаря и проверяваме всеки път какъв сегмент сме прочели. Ако срещнем подходящия проверяваме дали битът за подадения параметър е вдигнат. За това получаваме информация от тук :
https://www.geeksforgeeks.org/check-whether-k-th-bit-set-not/
Ако битът е вдигнат или не е и е подадена опция -G, то записваме стойността на параметъра в буфер и го изкарваме на конзолата отново с извикване на write, като ако сегментът е numeric, то с printf изкарваме просто числото като integer. Ако е byte отново имаме проверки дали символът е цифра, при което използваме printf. В случаите на numeric или byte segment отваряме отново файла за четене и местим указателя на точното място, вземайки под внимание на кой сегмент сме в момента и каква е позицията на параметъра, след което прочитаме съответно integer или само един byte. Ако в подадения файл няма сегмент с търсения параметър отново извеждаме съобщение за грешка и накрая затваряме дескриптора.

void showParameters(char* fileName, int flag) 
Тази функция приема име на файл и флаг, който съответства на опции -l и -L. Имаме проверка дали такъв файл съществува и ако да то минаваме през всеки сегмент. Проверяваме дали първия байт е 00, 01 или 02 и ако сме на съответния сегмент имаме още 3 проверки, с които установяваме дали всеки от трите бита на параметрите е вдигнат, ако това е необходимо и принтираме съответното име на параметъра. Проверката за това дали бит е 0 или 1 правим по същия начин, като в showValue. Накрая затваряме файловия дескриптор.

За командата -l (-L) с параметри използваме метод void showListedParameters(int argc, char* argv[], int flag), който минава през всички аргументи от масива argv и за всеки изпълняваме метода showValue.

void changeBit(char* fileName, char* parameter, char* change)

Тук приемаме име на файл, параметър и новата стойност на бита, съответстващ на този параметър. Валидираме дали подадените параметри са коректни и по подадения параметър, отново използвайки три променливи - type, position и num разбираме какъв точно сегмент търсим. Минавайки през всеки един, ако подаднем на подходящия променя бита на съответната позиция, зададена от името на параметъра по същия начин както в changeParameterValue. За целта отново отваряме файла за писане, поставяме указателя на позиция на търсения бит с lseek и презаписваме новата стойност. После затваряме дескриптора и накрая изкарваме съобщение за грешка ако не сме открили съответстващия на подадения параметър сегмент.

void createConfigFile(int argc, char* argv[])

Приемаме аргументите, подадени в main. Имаме проверка дали подадения за записване файл е с подходящо разширение. За това вземаме информация от тук :
https://stackoverflow.com/questions/5309471/getting-file-extension-in-c
След това използваме функция, с която си валидираме дали подадената поредица от индекси образува монотонно растяща редица с разлика 1. Ако това е изпълнено с 3 проверки установяваме какъв тип сегмент искаме да запишем и го правим, използвайки помощен буфер и извикване write. Накрая затваряме файловия дескриптор.

void showHelp() 

Последният метод, който използваме чете информация, която е предварително записана в помощен файл table.txt и ни извежда на стандартния изход информация за възможните функции, които програмата предлага. Изпълняваме тази команда и при всеки невалиден вход от потребителя, за да го насочим към правилния синтаксис на командите. Имаме още няколко функции, които преизползваме, за да реализираме горе споменатите.












