	Документация на Домашно №4

	Нека първо разгледаме хедъра comm.h. Там добавяме необходимите библиотеки, както и различни макроси за error съобщения, числови константи, имена на семафори и споделена памет. Използваме една структура, представена от int и масив от char, която ще ни служи за споделена памет между клиента и сървъра. Декларираме и три семафори - mutex за синхронизиране на отделните клиенти, clientReqest и serverResponse за синхронизация между клиент и сървър. 

	После разглеждаме client.c файла. Първо си валидираме, че ще получим аргумент, отговарящ на име на банкова сметка и също така, че той ще е е точно 1 символ. После с допълнителни помощни функции си инициализаре споделената памет (shm_open, за да създадем shared memory object, mmap, за да създадем нов mapping във виртуалното адресно пространство, като имаме валидация и при неуспешо тяхно изпъление излизаме с ненулев код за грешка) както и трите семафори, които ще използваме с имена от comm.h (използваме метода sem_open). Информация за тези функционалности получаваме от лекциите на Скелета POSIX_shm и POSIX_sem, както и от man страниците man shm_overview и man sem_overview.

	Използваме семафората mutex, за да синхронизираме различните клиенти да изчакват преди да бъда обслужени от сървъра, ако по това време сървърът вече обслужва друг клиент. За тази цел, след като сме set-нали стойността на семафората с 1, първо извикваме sem_wait и в края на критичната секция изпълняваме sem_post, за да освободим споделения ресурс. В самата критична секция първо инициализираме нулевия елемент от масива споделена памет със стойността на банковия акаунт. После информираме сървъра, че има заявка за обработване със sem_post(clientRequest) и веднага след това изчакваме сървърът да върне отговор с sem_wait(serverResponse). Тези семафори са с начални стойности 0, за да се изпълни горе споменатото коректно. След като сървърът е отговорил прочитаме информацията с функцията memcpy и използваме метода errorHandle, който обработва съобщението от сървъра, като ако то е съобщение за грешка, освобождаваме заетите ресурси и приключваме с ненулев код за грешка. В противен случай изкраваме баланса по сметката и прочитаме със scanf от стандартния вход 16 битово число. Пращаме го на сървъра като заявка и отново чакаме отговор, използвайки съответно sem_post(clientRequest) и sem_wait(serverResponse). Отново по аналогия имаме error handling и потеницално освобождаване на ресурси, накрая изпълняваме printf на съобщението, получено от сървъра, излизаме от критичната секция с sem_post(mutex) и освобождавме ресурса с munmap.

	Накрая остава и самият сървър - server.c. Отново имаме валидация дали ни е подаден файл и после инициализация на споделената памет и семафорите. Тук разликата с client.c e, че след като сме създали shared memory object-а трябва да му allocate-нем и памет, което се случва с ftruncate метода (отново е вземана информация от man страницата му). Понеже сървърът се пуска преди клиента, по тази причина това алокиране е в този файл. Използваме и допълнителна функция, с която проверяваме дали подаденият файл съществува, и ако не - създаваме такъв и запълваме 8 записа с 0, използвайки write и size-a на unit32_t. 

	За да може сървърът да работи постоянно пускаме безкраен while цикъл. Първоначално в него сървърът е приспан с sem_wait(clientRequest), очаквайки заявка от някой клиент. После ако случайно клиентът е изпратил невалиден акаунт, то му се изпраща съответното съобщение за грешка и минаваме на следващата итерация с continue, като преди това сме дали sem_post(serverResponse), за да може все пак клинетът да получи отговора. Ако номерът на сметка е правилен то с допълнителна функция getBalance вземаме текущият баланс, като изместваме с lseek указателят на правилната позиция и прочитаме uint32_t. След като сме получили информация за стойността по сметката записваме тази информация с memcpy в споделената памет и я изпращаме на клиента (чрез sem_post(serverResponse) ). Веднага след това приспиваме сървъра, докато не получи информация за клиентската заявка за промяна на стойността по сметка. Тогава изпълняваме метода updateBalance. При положителна стойност на заявката проверяваме дали при добавяне няма да overflow-нем, за което вземаме информация от тук : https://stackoverflow.com/questions/2633661/how-to-check-for-signed-integer-overflow-in-c-without-undefined-behaviour?fbclid=IwAR0PCt3uuXw72u9vQdK-AawGUiZoGd_0gaJq942FPOnvgudaMkyntreSmfk. Съответно ако прехвърли връщаме идентификатор на тази грешка, иначе преместваме указателя и презаписваме новата стойност. В противен случай, клиентът иска да тегли пари. Проверяваме дали текущият баланс е по-малък от модула на новата сума и ако да връщаме идентификатор за грешка иначе правим същото като в гориня случай, презаписваме промените. Благодарение на тази функция - updateBalance имаме информация дали промяната се е осъществила правилно или е възникнала грешка, съответно връщайки съобщение на клиента някое измежду следните :
"Transaction is successfull!" ; "Cannot withdraw that amount of money!" ; "Cannot deposit that amount of money!". След като запишем тази информация в споделената памет (отново с memcpy) ни остава само да уведомим клиента, че има отговор от сървъра, което правим с sem_post(serverResponse). Накрая на тази програма освобождаваме ресурсите - munmap, shm_unlink и unlink на трите семафори, както и затваряне на дескриптора на файла. За точната утотреба отново черпим информация от съответните man страници.	 








